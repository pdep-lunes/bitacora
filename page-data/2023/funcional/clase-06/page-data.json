{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2023/funcional/clase-06/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Bitácora","author":"pdep"}},"markdownRemark":{"id":"69fa2555-5b73-5039-8404-8a8889d5248b","excerpt":"Tarea para la clase que viene: Hacer una copia en su drive del documento y resolver el TP Pattern Matching Terminar la primera entrega del TP integrador ¿Qué…","html":"<h2 id=\"tarea-para-la-clase-que-viene\" style=\"position:relative;\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene:</h2>\n<ul>\n<li>Hacer una copia en su drive del documento y resolver el <a href=\"https://docs.google.com/spreadsheets/d/17YAHAtEX-xoHoepRP7hl1Nim_ZksYf96qgeN_Ct5BK4/edit#gid=0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TP Pattern Matching</a></li>\n<li>Terminar la primera entrega del <a href=\"https://docs.google.com/document/d/1Ot30lC7AZLUHCqrSrIOyQIk4SocKgWgYr_J_l1XrSV8/edit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TP integrador</a></li>\n</ul>\n<h2 id=\"qué-vimos-hoy\" style=\"position:relative;\"><a href=\"#qu%C3%A9-vimos-hoy\" aria-label=\"qué vimos hoy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Qué vimos hoy?</h2>\n<h3 id=\"expresiones-lambda\" style=\"position:relative;\"><a href=\"#expresiones-lambda\" aria-label=\"expresiones lambda permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Expresiones lambda</h3>\n<p>Comenzamos viendo una nueva manera de crear funciones, ¡las <strong>expresiones lambda</strong>! 🎉</p>\n<p>Si por ejemplo queremos obtener los dobles de una lista de números, hasta ahora podíamos hacerlo de esta manera…</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">dobles</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">dobles</span> <span class=\"token hvariable\">numeros</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span> <span class=\"token hvariable\">doble</span> <span class=\"token hvariable\">numeros</span>\n\n<span class=\"token hvariable\">dobles</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token hvariable\">doble</span> <span class=\"token hvariable\">numero</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">numero</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span></code></pre></div>\n<p>… o de esta…</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">dobles</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">dobles</span> <span class=\"token hvariable\">numeros</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">numeros</span></code></pre></div>\n<p>Con expresiones lambda podríamos hacer lo siguiente:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">dobles</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">dobles</span> <span class=\"token hvariable\">numeros</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">numeros</span></code></pre></div>\n<p>¿Esto significa que a partir de ahora todas nuestras funciones las vamos a definir utilizando expresiones lambda? ¡No! ✋ Solo estamos viendo una nueva herramienta dentro del amplio espectro del paradigma funcional. De hecho, también se conoce a estas funciones como funciones anónimas 👤, ya que, si bien podemos darles un nombre, solemos utilizarlas para casos muy específicos donde no nos interesa darle demasiada entidad a esa lógica. Entonces, ¿cuándo usarlas?</p>\n<ul>\n<li>Cuando no tenemos un buen nombre para ponerle a una función.</li>\n<li>Si sólo la vamos a usar una única vez, sino estamos repitiendo lógica.</li>\n<li>Si no necesitamos usar guardas ni pattern matching (con más de una ecuación).</li>\n</ul>\n<h3 id=\"currificación-y-parámetros-implícitos\" style=\"position:relative;\"><a href=\"#currificaci%C3%B3n-y-par%C3%A1metros-impl%C3%ADcitos\" aria-label=\"currificación y parámetros implícitos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Currificación y parámetros implícitos</h3>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- Sin currificar</span>\n<span class=\"token hvariable\">sumaDe3</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">sumaDe3</span> <span class=\"token hvariable\">numero1</span> <span class=\"token hvariable\">numero2</span> <span class=\"token hvariable\">numero3</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span></code></pre></div>\n<p>¡Hay otra forma de escribir esto! 😮 Teniendo en cuenta que <code class=\"language-text\">sumaDe3</code> es una función, ¡lo podemos realizar con una lambda!:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumaDe3'</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumaDe3'</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero1</span> <span class=\"token hvariable\">numero2</span> <span class=\"token hvariable\">numero3</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>A diferencia de <code class=\"language-text\">sumaDe3</code>, se utiliza una lambda para realizar su definición. Por eso (de forma didáctica), su tipo es la función <code class=\"language-text\">(Int -> Int -> Int -> Int)</code>.</p>\n<p>Si realizamos esta consulta en consola:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> sumaDe3 5\n&lt;function></code></pre></div>\n<p>Esto ocurre porque, como ya vimos, podemos crear funciones si llamamos, utilizando aplicación parcial, a otras funciones. Si vemos el tipo de <code class=\"language-text\">sumaDe3 5</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">>:t sumaDe3 5\n(sumaDe3 5) :: Int -> Int -> Int</code></pre></div>\n<p>Ahora, si vemos el tipo de <code class=\"language-text\">sumaDe3</code>, ¿refleja bien lo que está ocurriendo?\nVeamos si hacemos, utilizando lambdas, algo que refleje mejor esto:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumaDe3''</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumaDe3''</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero1</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero2</span> <span class=\"token hvariable\">numero3</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>¡Gracias a esto podemos aplicar parcialmente nuestras funciones! Cuando llamamos a <code class=\"language-text\">sumaDe3'' 5</code>, nos va a devolver la segunda función lambda que creamos.</p>\n<p>¡Pero sabemos que <code class=\"language-text\">sumaDe3 5 5</code> también nos devuelve una función!</p>\n<p>Si queremos hacer una función que replique todos los casos, tendríamos que hacer algo así:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumaDe3'''</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumaDe3'''</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero1</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero2</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero3</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>¿Esto quiere decir que ahora todas las funciones las tenemos que hacer así? ¿Y tiparlas así? 😨 De nuevo: <strong>¡no!</strong> A lo que llegamos, es que <em>Haskell hace esto sin que nos demos cuenta</em>: lo que hace haskell es “partir” nuestra función en diferentes funciones de 1 parámetro, es decir, <em>currifica</em> nuestras funciones.</p>\n<p>Ahora, entendiendo esto, llegamos a por qué existe aplicación parcial: si le pasamos un parámetro a <code class=\"language-text\">sumaDe3</code>, nos va a devolver la <em>siguiente</em> función, que toma dos parámetros y nos devuelve un entero.</p>\n<p>En Haskell, a veces, podemos dejar implícitos los parámetros que se pasan a las funciones. ¿Esto qué significa? 🤔 Que no es necesario escribir a la izquierda del <code class=\"language-text\">=</code> que estamos recibiendo ese parámetro.\nVeamos un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">siguiente</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">siguiente</span> <span class=\"token hvariable\">numero</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">numero</span>\n<span class=\"token comment\">-- es equivalente a</span>\n<span class=\"token hvariable\">siguiente</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></code></pre></div>\n<p>Esto es porque al haber aplicado un <code class=\"language-text\">1</code> a la función <code class=\"language-text\">+</code>, nos va a devolver una función <code class=\"language-text\">Int -> Int</code>. Justamente, ¡¡gracias a que todas las funciones en Haskell están currificadas!! 🙌</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span>    <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span> <span class=\"token operator\">::</span>          <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code></pre></div>\n<p>En este caso, <code class=\"language-text\">siguiente</code> estaría “recibiendo implícitamente” un <code class=\"language-text\">numero :: Int</code>.\nY lo que estamos haciendo es simplemente darle un nuevo nombre a esa función, porque es un valor.</p>\n<p>Los parámetros implícitos también son útiles y frecuentemente vistos en los casos en los que componemos funciones.</p>\n<p>Volviendo al <em>TP “Hora de lectura”</em>, teníamos esta función:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">nombreDeLaBiblioteca</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Biblioteca</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">nombreDeLaBiblioteca</span> <span class=\"token hvariable\">unaBiblioteca</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">sinVocales</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">concatenatoriaDeTitulos</span> <span class=\"token operator\">$</span> <span class=\"token hvariable\">unaBiblioteca</span></code></pre></div>\n<p>Ahora que sabemos que podemos dejar implícitos nuestros parámetros, podríamos reescribirla de esta manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">nombreDeLaBiblioteca</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Biblioteca</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">nombreDeLaBiblioteca</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">sinVocales</span> <span class=\"token operator\">.</span> <span class=\"token hvariable\">concatenatoriaDeTitulos</span></code></pre></div>\n<p>En este caso <code class=\"language-text\">nombreDeLaBiblioteca</code> recibe implícitamente a un <code class=\"language-text\">biblioteca :: Biblioteca</code>. Esto es porque a la derecha del igual tenemos una función <code class=\"language-text\">Biblioteca -> Biblioteca</code>, a la que le queremos poner un nombre, porque para nosotros esa función significa <code class=\"language-text\">nombreDeLaBiblioteca</code>.</p>\n<p>Esto no significa que de aquí en adelante sea importante dejar implícitos nuestros parámetros. Podemos hacerlo o no y nuestras funciones resolverán exactamente los mismos problemas de la misma forma ya que la lógica no cambia.</p>\n<h3 id=\"patrones-de-listas\" style=\"position:relative;\"><a href=\"#patrones-de-listas\" aria-label=\"patrones de listas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Patrones de listas</h3>\n<p>Además del ya conocido patrón de lista vacía (<code class=\"language-text\">[]</code>), existe otro patrón que nos puede resultar útil: el de <em>cabeza y cola</em> <code class=\"language-text\">(cabeza:cola)</code>. De esta forma estamos describiendo una lista de por lo menos un elemento.\nSi quisiéramos describir a una lista de por lo menos dos elementos, podríamos aplicar el patrón: <code class=\"language-text\">(unElemento:otroElemento:cola)</code>.</p>\n<h3 id=\"recursividad\" style=\"position:relative;\"><a href=\"#recursividad\" aria-label=\"recursividad permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursividad</h3>\n<ul>\n<li>Caso base: corta la recursividad.</li>\n<li>Caso recursivo: donde la función se llama a sí misma.</li>\n</ul>\n<p>Ejemplos comunes de esto son la sucesión de fibonacci 🐌  y el factorial ❗:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorial</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">factorial</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>                            <span class=\"token comment\">-- caso base</span>\n<span class=\"token hvariable\">factorial</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">factorial</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">-- caso recursivo</span>\n\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>                                                     <span class=\"token comment\">-- caso base</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>                                                     <span class=\"token comment\">-- caso base</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">-- caso recursivo</span></code></pre></div>\n<p>Pero esto no se reduce solo a funciones matemáticas que rara vez usemos en nuestros programas, la recursividad también sirve para funciones más comunes corrientes como <code class=\"language-text\">length</code> que nos permite saber el largo de una lista:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">length</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>        <span class=\"token operator\">=</span> <span class=\"token number\">0</span>                   <span class=\"token comment\">-- caso base</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">length</span> <span class=\"token hvariable\">xs</span> <span class=\"token comment\">-- caso recursivo</span></code></pre></div>\n<p>Acá podemos aprovechar y ver qué significa cada parte de la declaración de la función.</p>\n<ul>\n<li>Cuando decimos <code class=\"language-text\">length [ ] = ...</code> estamos diciendo que cuando la lista encaje con ese patrón (<code class=\"language-text\">[ ]</code> es el patrón de lista vacía) la función devuelve lo que está a la derecha.</li>\n<li>Cuando ponemos <code class=\"language-text\">length (_:xs) = ...</code> estamos diciendo que cuando la lista tenga cabeza y cola (el patrón es <code class=\"language-text\">(cabeza:cola)</code>) la función devuelve lo que está del lado derecho. Acá es importante ver cómo usamos la variable anónima (<code class=\"language-text\">_</code>) para decir que queremos que tenga cabeza pero que no nos importa que valor tiene la cabeza.</li>\n<li>Lo importante es que quede claro que lo mismo escrito del lado izquierdo del igual y del lado derecho no tienen el mismo significado, cuando vemos lo siguiente: <code class=\"language-text\">(x:xs)</code> no podemos decir si eso corresponde al patrón de lista (cabeza:cola) o si corresponde a usar la función <code class=\"language-text\">:</code> con <code class=\"language-text\">x</code> y <code class=\"language-text\">xs</code>. Lo mismo sucede con el patrón de lista vacía y la lista vacía (en ambos casos es <code class=\"language-text\">[ ]</code>, del lado izquierdo patrón y del lado derecho la lista vacía).</li>\n</ul>\n<p>Ahora, intentemos hacer la definición de <code class=\"language-text\">sum</code> y <code class=\"language-text\">product</code> de manera recursiva:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">sum</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">sum</span>       <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token builtin\">sum</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">sum</span> <span class=\"token hvariable\">xs</span>\n\n<span class=\"token hvariable\">produc</span> <span class=\"token hvariable\">t</span><span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token builtin\">product</span>                       <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token builtin\">product</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cabeza</span> <span class=\"token operator\">:</span> <span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cabeza</span> <span class=\"token operator\">*</span> <span class=\"token builtin\">product</span> <span class=\"token hvariable\">cola</span></code></pre></div>\n<p>Si comparamos con las definiciones anteriores de <code class=\"language-text\">sum</code> y <code class=\"language-text\">product</code>, vemos que hay una repetición de lógica:</p>\n<ul>\n<li>En ambas definiciones esperamos que, cuando la lista esté vacía, retornemos un caso base.</li>\n<li>Luego, en ambas definiciones realizamos una operación que involucra el primer elemento de la lista, un operador (<code class=\"language-text\">+</code> o <code class=\"language-text\">*</code>) y una llamada recursiva de la función que estamos definiendo con la cola de la lista como parámetro.</li>\n</ul>\n<h3 id=\"fold\" style=\"position:relative;\"><a href=\"#fold\" aria-label=\"fold permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fold</h3>\n<p>Para solucionar este problema de repetición de lógica, surge <code class=\"language-text\">fold</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- Tipo de foldr</span>\n\n<span class=\"token builtin\">foldr</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n\n<span class=\"token comment\">-- Caso base: si la lista está vacía, retorno el acumulador</span>\n\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">acumulador</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>     <span class=\"token operator\">=</span>  <span class=\"token hvariable\">acumulador</span>\n\n<span class=\"token comment\">-- Caso recursivo: si la lista no está vacía, ejecuto el operador con la cabeza de la lista y la llamada recursiva con la cola de la lista</span>\n\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">operador</span> <span class=\"token hvariable\">acumulador</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cabeza</span> <span class=\"token operator\">:</span> <span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cabeza</span> <span class=\"token operator\">`operador`</span> <span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">operador</span> <span class=\"token hvariable\">acumulador</span> <span class=\"token hvariable\">cola</span></code></pre></div>\n<p>Ahora, las funciones de <code class=\"language-text\">sum</code> y <code class=\"language-text\">product</code> las podemos realizar sin repetir lógica:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">sum</span> <span class=\"token hvariable\">lista</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldr</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token hvariable\">lista</span>\n\n<span class=\"token builtin\">product</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token builtin\">product</span> <span class=\"token hvariable\">lista</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldr</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">lista</span>\n\n<span class=\"token hvariable\">sumarUno</span> <span class=\"token hvariable\">valorAnterior</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">valorAnterior</span>\n<span class=\"token builtin\">length</span> <span class=\"token hvariable\">lista</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">sumarUno</span> <span class=\"token number\">0</span> <span class=\"token hvariable\">lista</span></code></pre></div>\n<p>También, existe la función <code class=\"language-text\">foldl</code> que tiene la misma funcionalidad que <code class=\"language-text\">foldr</code> <em>pero</em> aplica la función recursiva cambiando la posición de los parámetros de la función que le pasamos por parámetro. ¡Así que cuidado con usarla con funciones que no sean asociativas! Por ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- Como la suma es asociativa, obtenemos el mismo resultado si hacemos:</span>\n\n<span class=\"token builtin\">foldr</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">></span> <span class=\"token number\">10</span>\n\n<span class=\"token comment\">-- o:</span>\n\n <span class=\"token builtin\">foldl</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">></span> <span class=\"token number\">10</span>\n\n<span class=\"token comment\">-- Pero si utilizamos fold con la resta que no es asociativa:</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">2</span>\n\n<span class=\"token comment\">-- No obtenemos los mismos resultados:</span>\n\n<span class=\"token builtin\">foldl</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span>\n<span class=\"token operator\">></span> <span class=\"token operator\">-</span><span class=\"token number\">10</span></code></pre></div>\n<p>¿Y qué pasa en los casos donde no se puede incluir un acumulador? (Por ejemplo, averiguar el máximo número de una lista de números). Para esto, tenemos las funciones <code class=\"language-text\">foldl1</code> y <code class=\"language-text\">foldr1</code>. En los siguientes ejemplos podemos ver que toma como acumulador al primer elemento de la lista:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldl1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">xs</span>\n\n<span class=\"token builtin\">foldr1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">foldr1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<h2 id=\"links-útiles\" style=\"position:relative;\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links útiles permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links Útiles</h2>\n<ul>\n<li><a href=\"https://drive.google.com/file/d/1_OOHBV8A7ixwUYX4wRihRiYDmQ2GIBvw/view?usp=sharing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Video de la clase del 2022</a></li>\n<li><a href=\"https://github.com/pdep-lunes/pdep-clases-2023/blob/main/Funcional/Clase06/src/Lib.hs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Código de la clase</a></li>\n<li><a href=\"http://wiki.uqbar.org/wiki/articles/expresiones-lambda.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Expresiones Lambda</a></li>\n<li><a href=\"http://wiki.uqbar.org/wiki/articles/currificacion.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Currificación</a></li>\n<li><a href=\"http://wiki.uqbar.org/wiki/articles/recursividad-en-haskell.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Recursividad en haskell</a></li>\n<li><a href=\"https://docs.google.com/document/d/1jSrU7lVMan4nbHBETGqvO5VpqJI0KXVWtH7fqnVASPU/edit?usp=sharing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">La familia fold</a></li>\n<li>Formas de ver fold interactivas: <a href=\"https://stevekrouse.com/hs.js/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stevekrouse.com/hs.js/</a> y <a href=\"https://pdep-lunes-fold.netlify.app/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pdep-lunes-fold.netlify.app/</a></li>\n</ul>","frontmatter":{"title":"Sexta clase","date":"08-05-2023","description":"Sexta clase de PdeP","tags":["funcional","currificación","expresiones lambda","recursividad","fold"]}}},"pageContext":{"slug":"/2023/funcional/clase-06/","previous":{"fields":{"slug":"/2023/funcional/clase-05/"},"frontmatter":{"title":"Quinta clase","date":"24-04-2023"}},"next":null}},
    "staticQueryHashes": ["452372368","63159454"]}