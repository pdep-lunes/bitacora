{"componentChunkName":"component---src-templates-blog-post-js","path":"/funcional/clase-06/","webpackCompilationHash":"02ec63fa2a729b4105ad","result":{"data":{"site":{"siteMetadata":{"title":"Bitácora","author":"pdep"}},"markdownRemark":{"id":"046677a5-853b-5937-9bd3-0e1de0ccbc46","excerpt":"Tarea para la clase que viene Hacer los nuevos puntos del Monopoly Recargado Ver la solución propuesta a la primera parte del tp y hacer consultas (hay un video…","html":"<h2 id=\"tarea-para-la-clase-que-viene\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene</h2>\n<ul>\n<li>Hacer los nuevos puntos del <a href=\"https://docs.google.com/document/d/1--4XJTZqk49fEXxwGJjoQwoc_MfNAymheY-BJ2IRS40\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Monopoly Recargado</a></li>\n<li>Ver la <a href=\"https://github.com/pdep-lunes/monopoly\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">solución propuesta</a> a la primera parte del tp y hacer consultas (hay un <a href=\"https://www.youtube.com/watch?v=lXsX8wsR7AI\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">video</a> con el paso a paso).</li>\n</ul>\n<hr>\n<h2 id=\"¿qué-vimos-hoy\"><a href=\"#%C2%BFqu%C3%A9-vimos-hoy\" aria-label=\"¿qué vimos hoy permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Qué vimos hoy?</h2>\n<p>Empezamos repasando lambdas, conociendo el concepto de currificación y viendo cómo es que llegamos a poder escribir con parámetros implícitos debido a lo anterior. Seguimos viendo que es la recursividad, cuando la usamos, cuando repetimos lógica y cómo podemos usar fold para evitar esa repetición y ser más declarativos.</p>\n<hr>\n<h3 id=\"currificación-y-parámetros-implícitos\"><a href=\"#currificaci%C3%B3n-y-par%C3%A1metros-impl%C3%ADcitos\" aria-label=\"currificación y parámetros implícitos permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Currificación y parámetros implícitos</h3>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">-- Sin currificar</span>\n<span class=\"token hvariable\">sumaDe3</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">sumaDe3</span> <span class=\"token hvariable\">numero1</span> <span class=\"token hvariable\">numero2</span> <span class=\"token hvariable\">numero3</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span></code></pre></div>\n<p>¡Hay otra forma de escribir esto! Teniendo en cuenta que sumaDe3 es una función, ¡lo podemos realizar con una lambda!:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumaDe3</span>' <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumaDe3</span>' <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero1</span> <span class=\"token hvariable\">numero2</span> <span class=\"token hvariable\">numero3</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>A diferencia de sumaDe3, se utiliza una lambda para realizar su definición. Por eso (de forma didáctica), su tipo es la función (Int -> Int -> Int -> Int).</p>\n<p>Si realizamos esta consulta en consola:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token operator\">></span> <span class=\"token hvariable\">sumaDe3</span> <span class=\"token number\">5</span>\n<span class=\"token operator\">&lt;</span><span class=\"token hvariable\">function</span><span class=\"token operator\">></span></code></pre></div>\n<p>Esto ocurre porque, como ya vimos, podemos construir nuevas funciones aplicando parcialmente funciones ya definidas. Si vemos el tipo de <code class=\"language-text\">sumaDe3 5</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token operator\">>:</span><span class=\"token hvariable\">t</span> <span class=\"token hvariable\">sumaDe3</span> <span class=\"token number\">5</span>\n<span class=\"token punctuation\">(</span><span class=\"token hvariable\">sumaDe3</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code></pre></div>\n<p>Ahora, si vemos el tipo de <code class=\"language-text\">sumaDe3</code>, ¿Refleja bien lo que está ocurriendo?\nVeamos si hacemos, utilizando lambdas, algo que refleje mejor esto:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumaDe3</span>'' <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumaDe3</span>'' <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero1</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero2</span> <span class=\"token hvariable\">numero3</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>¡Por esto es que ocurre la aplicación parcial! Cuando llamamos a <code class=\"language-text\">sumaDe3&#39;&#39; 5</code>, nos va a devolver la segunda función lambda que creamos.</p>\n<p>¡Pero sabemos que <code class=\"language-text\">sumaDe3 5 5</code> también nos devuelve una función!</p>\n<p>Si queremos hacer una función que replique todos los casos, tendriamos que hacer algo asi:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumaDe3</span>''' <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">sumaDe3</span>''' <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero1</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero2</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">numero3</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">numero1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero2</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">numero3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>¿Esto quiere decir que ahora todas las funciones las tenemos que hacer así? ¿Y tiparlas así? ¡No! A lo que llegamos, es que <em>Haskell hace esto sin que nos demos cuenta</em>: Lo que hace haskell es “partir” nuestra función en diferentes funciones de 1 parámetro, es decir, <em>currifica</em> nuestras funciones.</p>\n<p>Ahora, entendiendo esto, llegamos a por qué existe aplicación parcial: Si le pasamos un parámetro a <code class=\"language-text\">sumaDe3</code>, nos va a devolver la <em>siguiente</em> función, que toma dos parámetros y nos devuelve un entero.</p>\n<p>En Haskell, a veces, podemos dejar implícitos los parámetros que se pasan a las funciones. ¿Esto qué significa? Que no es necesario escribir a la izquierda del <code class=\"language-text\">=</code> que estamos recibiendo ese parámetro.\nVeamos un ejemplo:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">siguiente</span> <span class=\"token hvariable\">numero</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span> <span class=\"token hvariable\">numero</span>\n<span class=\"token comment\">-- es equivalente a</span>\n<span class=\"token hvariable\">siguiente</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span></code></pre></div>\n<p>Esto es porque al haber aplicado un <code class=\"language-text\">1</code> a la función <code class=\"language-text\">+</code>, nos va a devolver una función <code class=\"language-text\">Int -&gt; Int</code>. Justamente, gracias a que todas las funciones en Haskell están currificadas!!</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span>   <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1</span> <span class=\"token operator\">::</span>        <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code></pre></div>\n<p>En este caso, <code class=\"language-text\">siguiente</code> estaría recibiendo implícitamente un <code class=\"language-text\">numero :: Int</code>.\nY lo que estamos haciendo es simplemente darle un nuevo nombre a esa función, porque es un valor.</p>\n<p>Los parámetros implícitos también son útiles y frecuentemente vistos en los casos en los que componemos funciones.</p>\n<p>Usando un ejemplo del dominio de Monopoly:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">aumentarDinero</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Dinero</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Jugador</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Jugador</span>\n<span class=\"token hvariable\">cambiarTactica</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Tactica</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Jugador</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Jugador</span>\n\n<span class=\"token hvariable\">pasarPorElBanco</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Jugador</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Jugador</span>\n                               <span class=\"token comment\">--  (Jugador -> Jugador) . (Jugador -> Jugador)</span>\n<span class=\"token hvariable\">pasarPorElBanco</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cambiarTactica</span> <span class=\"token string\">\"Comprador Compulsivo\"</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">aumentarDinero</span> <span class=\"token number\">40</span></code></pre></div>\n<p>En este caso <code class=\"language-text\">pasarPorElBanco</code> recibe implícitamente a un <code class=\"language-text\">jugador::Jugador</code>. Esto es porque a la derecha del igual tenemos una función <code class=\"language-text\">Jugador -&gt; Jugador</code>, a la que le queremos poner un nombre, porque para nosotros esa función significa <code class=\"language-text\">pasarPorElBanco</code>.</p>\n<hr>\n<h3 id=\"recursividad\"><a href=\"#recursividad\" aria-label=\"recursividad permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursividad</h3>\n<p>Probablemente ya hayan visto recursividad en materias como Algoritmos y Estrucutras de Datos, Matemática Discreta o hasta Análisis Matemático.</p>\n<p>La lógica en este caso es la misma, estamos hablando de una función que se usa a si misma dentro de su definición. Consta principalmente de dos casos:</p>\n<ul>\n<li>Caso base, corta la recursividad.</li>\n<li>Caso recursivo, donde la función se llama a sí misma.</li>\n</ul>\n<p>Ejemplos comunes de esto son la sucesión de fibonacci y el factorial:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorial</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">factorial</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>                     <span class=\"token comment\">-- caso base</span>\n<span class=\"token hvariable\">factorial</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">factorial</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">-- caso recursivo</span>\n\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>                                     <span class=\"token comment\">-- caso base</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>                                     <span class=\"token comment\">-- caso base</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\">-- caso recursivo</span></code></pre></div>\n<p>Pero esto no se reduce solo a funciones matemáticas que rara vez usemos en nuestros programas, la recursividad también sirve para funciones más comunes y corrientes como <code class=\"language-text\">length</code> que nos permite saber el largo de una lista:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">length</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>       <span class=\"token operator\">=</span> <span class=\"token number\">0</span>               <span class=\"token comment\">-- caso base</span>\n<span class=\"token builtin\">length</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token operator\">:</span><span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">length</span> <span class=\"token hvariable\">cola</span> <span class=\"token comment\">-- caso recursivo</span></code></pre></div>\n<p>Acá podemos hacer un parate y ver qué significa cada parte de la declaración de la función:</p>\n<ul>\n<li>Cuando decimos <code class=\"language-text\">length [ ] = ...</code> estamos diciendo que cuando la lista encaje con ese patrón (<code class=\"language-text\">[ ]</code> es el patrón de lista vacía) la función devuelve lo que está a la derecha.</li>\n<li>Cuando ponemos <code class=\"language-text\">length (_:cola) = ...</code> estamos diciendo que cuando la lista tenga cabeza y cola (el patrón es <code class=\"language-text\">(cabeza:cola)</code>) la función devuelve lo que está del lado derecho. Acá es importante ver como usamos la variable anónima (<code class=\"language-text\">_</code>) para decir que queremos que tenga cabeza pero que no nos importa que valor tiene la cabeza.</li>\n</ul>\n<blockquote>\n<p>Lo importante es que quede claro que lo mismo escrito del lado izquierdo del igual y del lado derecho no tienen el mismo significado, cuando vemos lo siguiente: <code class=\"language-text\">(cabeza:cola)</code> no podemos decir si eso corresponde al patrón de lista (cabeza:cola) o si corresponde a usar la función <code class=\"language-text\">:</code> con <code class=\"language-text\">cabeza</code> y <code class=\"language-text\">cola</code>. Lo mismo sucede con el patrón de lista vacía y la lista vacía (en ambos casos es <code class=\"language-text\">[ ]</code>, del lado izquierdo patrón y del lado derecho lista vacía). Por último, la variable anónima <code class=\"language-text\">_</code> no es un valor, solo la usamos como patrón.</p>\n</blockquote>\n<p>Ahora, intentemos hacer la definición de <code class=\"language-text\">sum</code> de manera recursiva:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">sum</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">sum</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>            <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token builtin\">sum</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cabeza</span><span class=\"token operator\">:</span><span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cabeza</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">sum</span> <span class=\"token hvariable\">cola</span></code></pre></div>\n<p>Si comparamos con la definición anterior de <code class=\"language-text\">length</code>, vemos que hay una repetición de lógica:</p>\n<ul>\n<li>En ambas definiciones esperamos que cuando la lista esté vacía la función retorne 0.</li>\n<li>Luego, en ambas definiciones realizamos una operación que involucra el primer elemento de la lista, una función <code class=\"language-text\">f</code> y una llamada recursiva de la función que estamos definiendo con la cola de la lista como parámetro.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">any</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token builtin\">any</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>             <span class=\"token operator\">=</span> <span class=\"token constant\">False</span>\n<span class=\"token builtin\">any</span> <span class=\"token hvariable\">predicado</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">predicado</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">||</span> <span class=\"token builtin\">any</span> <span class=\"token hvariable\">predicado</span> <span class=\"token hvariable\">xs</span>\n\n<span class=\"token builtin\">all</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token builtin\">all</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>             <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n<span class=\"token builtin\">all</span> <span class=\"token hvariable\">predicado</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">predicado</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin\">all</span> <span class=\"token hvariable\">predicado</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<p>Para solucionar este problema de repetición de lógica, surgen las funciones de la familia <code class=\"language-text\">fold</code></p>\n<p>Empezamos por <code class=\"language-text\">foldl</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token comment\">--    :: funcion -> neutro/semilla -> lista -> a</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">b</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n\n<span class=\"token comment\">-- caso base, si la lista está vacía, retorno la semilla</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>     <span class=\"token operator\">=</span>  <span class=\"token hvariable\">semilla</span>\n\n<span class=\"token comment\">-- caso recursivo, si la lista no esta vacia, ejecuto la funcion con la semilla y la cabeza, y hago una llamada recursiva con eso y la cola de la lista</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cabeza</span><span class=\"token operator\">:</span><span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token hvariable\">cabeza</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">cola</span>\n\n<span class=\"token comment\">-- básicamnente foldl recibe:</span>\n<span class=\"token comment\">-- * una función</span>\n<span class=\"token comment\">-- * una semilla o valor para el caso base</span>\n<span class=\"token comment\">-- * una lista</span>\n<span class=\"token comment\">-- devuelve el valor para el caso base si la lista es vacia</span>\n<span class=\"token comment\">-- y vuelve a usar foldl usando el resultado de aplicar la funcion a la semilla y la cabeza como nueva semilla</span>\n<span class=\"token comment\">-- y la cola de la lista como nueva lista (para este nuevo uso de foldl)</span></code></pre></div>\n<p>Ahora, las funciones de <code class=\"language-text\">sum</code> y <code class=\"language-text\">length</code> las podemos realizar sin repetir lógica:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">sum</span> <span class=\"token hvariable\">lista</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0</span> <span class=\"token hvariable\">lista</span>\n\n<span class=\"token hvariable\">sumarUno</span> <span class=\"token hvariable\">valorAnterior</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">valorAnterior</span>\n<span class=\"token builtin\">length</span> <span class=\"token hvariable\">lista</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">sumarUno</span> <span class=\"token number\">0</span> <span class=\"token hvariable\">lista</span></code></pre></div>\n<p>También, existe la función <code class=\"language-text\">foldr</code> que tiene la misma funcionalidad que <code class=\"language-text\">foldl</code> <em>pero</em> aplica la función recursiva cambiando la posición de los parametros de la función que le pasamos por parametro y de otra forma:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldr</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">semilla</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cabeza</span><span class=\"token operator\">:</span><span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">cabeza</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token hvariable\">cola</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">-- básicamnente foldr recibe:</span>\n<span class=\"token comment\">-- * una función (con los parámetros al revés que la defoldl)</span>\n<span class=\"token comment\">-- * una semilla o valor para el caso base</span>\n<span class=\"token comment\">-- * una lista</span>\n<span class=\"token comment\">-- devuelve el valor para el caso base si la lista es vacia</span>\n<span class=\"token comment\">-- y evalua la funcion con la cabeza de la lista y el resultado de foldear la cola</span></code></pre></div>\n<p>¿Y qué pasa en los casos donde no puedo incluir una semilla? (Por ejemplo, averiguar el máximo número de una lista de números). Para esto, tenemos las funciones <code class=\"language-text\">foldl1</code> y <code class=\"language-text\">foldr1</code> que toman como semilla o valor base el primer elemento de la lista:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldl1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">xs</span>\n\n<span class=\"token builtin\">foldr1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">foldr1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<p>La idea ahora <strong>no</strong> es que dejen de usar <code class=\"language-text\">sum</code>, <code class=\"language-text\">length</code>, <code class=\"language-text\">any</code> y <code class=\"language-text\">all</code> para hacer todo eso con foldl, justamente porque esos “problemas” ya están resueltos. Lo importante es que lo tengamos en cuenta para cuando necesitemos “plegar” una lista usando alguna función o cuando tengamos el instinto de hacer algo recursivo cuando quizás podría quedar más declarativo con <code class=\"language-text\">fold</code>.</p>\n<hr>\n<h2 id=\"links-útiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links útiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links Útiles</h2>\n<!-- - [Video de la clase](...)\n-  -->\n<ul>\n<li><a href=\"https://drive.google.com/open?id=1mbSZHPZphl0T0jfB6hU21YjhySdoyx3p\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Video de la clase</a></li>\n<li>Leer el documento sobre las funciones de la familia fold que está <a href=\"https://docs.google.com/document/d/1jSrU7lVMan4nbHBETGqvO5VpqJI0KXVWtH7fqnVASPU/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">acá</a></li>\n</ul>","frontmatter":{"title":"Sexta clase","date":"11-05-2020","description":"Sexta clase de PdeP","tags":["funcional","currificacion","recursividad","fold"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/funcional/clase-06/","previous":{"fields":{"slug":"/funcional/clase-05/"},"frontmatter":{"title":"Quinta clase"}},"next":{"fields":{"slug":"/funcional/clase-07/"},"frontmatter":{"title":"Séptima clase"}}}}}