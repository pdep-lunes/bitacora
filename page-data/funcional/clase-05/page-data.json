{"componentChunkName":"component---src-templates-blog-post-js","path":"/funcional/clase-05/","webpackCompilationHash":"1ee2f407673af3c975f9","result":{"data":{"site":{"siteMetadata":{"title":"BitÃ¡cora","author":"pdep"}},"markdownRemark":{"id":"2b13b442-8067-5141-bb11-980e77408a18","excerpt":"Tarea para la clase que viene Primer entrega del TP. Hacer lecciones 7, 8 y 9 de Mumuki. Â¿QuÃ© vimos hoy? Pattern Matching Tuplas Data Git Pattern Matchingâ€¦","html":"<h2 id=\"tarea-para-la-clase-que-viene\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene</h2>\n<ul>\n<li>Primer entrega del TP.</li>\n<li>Hacer lecciones 7, 8 y 9 de <a href=\"https://mumuki.io/pdep-utn\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mumuki</a>.</li>\n</ul>\n<h2 id=\"Â¿quÃ©-vimos-hoy\"><a href=\"#%C2%BFqu%C3%A9-vimos-hoy\" aria-label=\"Â¿quÃ© vimos hoy permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Â¿QuÃ© vimos hoy?</h2>\n<ol>\n<li>Pattern Matching</li>\n<li>Tuplas</li>\n<li>Data</li>\n<li>Git</li>\n</ol>\n<h2 id=\"pattern-matching\"><a href=\"#pattern-matching\" aria-label=\"pattern matching permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pattern Matching</h2>\n<p>Quisimos hacer una funciÃ³n que nos diga el gusto de helado ğŸ¦ de cada persona. Con lo que sabÃ­amos planteamos esta soluciÃ³n:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token hvariable\">nombre</span>\n  <span class=\"token operator\">|</span> <span class=\"token hvariable\">nombre</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Crema americana\"</span>\n  <span class=\"token operator\">|</span> <span class=\"token hvariable\">nombre</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Marcelo\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Menta granizada\"</span>\n  <span class=\"token operator\">|</span> <span class=\"token hvariable\">nombre</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Rocio\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Chocolate blanco\"</span>\n  <span class=\"token operator\">|</span> <span class=\"token builtin\">otherwise</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Kinotos al whiskey\"</span></code></pre></div>\n<p>Ufff todo eso y solo fueron 3 nombres ğŸ˜“ Â¿Â¡QuÃ© pasarÃ­a si fueran mÃ¡s!? TendrÃ­amos que seguir comparando por igual al parÃ¡metro con los nombres que vayamos agregando por cada guarda ğŸ˜±. Â¿No habrÃ¡ otra soluciÃ³n donde no repitamos tanto lo que hacemos? La respuesta es sÃ­ y se llama <strong>pattern matching</strong> ğŸ˜. No Peter Machine. ğŸ˜\nVeamos como codeamos esa soluciÃ³n: ğŸ‘€</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Crema americana\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Marcelo\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Menta granizada\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Rocio\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Chocolate blanco\"</span></code></pre></div>\n<p>Â¿Con eso nos alcanzaba? Â¿QuÃ© pasaba si preguntÃ¡bamos por un nombre que no aparece en lo que definimos? ğŸ¤” Veamos:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token operator\">></span> <span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Gus\"</span>\nğŸ’¥</code></pre></div>\n<p>Para eso es que tenemos que definir nuestro <em>otherwise</em> pero del pattern matching y eso lo hacemos asÃ­:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Crema americana\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Marcelo\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Menta granizada\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Rocio\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Chocolate blanco\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token hvariable\">otroNombre</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Kinotos al whiskey\"</span></code></pre></div>\n<p>Â¡Ahora sÃ­! Â¿Pero estamos usando el parÃ¡metro <code class=\"language-text\">otroNombre</code> del otro lado del <code class=\"language-text\">=</code>? Nop ğŸ˜…. Para eso es que recurrimos a la <strong>variable anÃ³nima</strong>: <code class=\"language-text\">_</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Crema americana\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Marcelo\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Menta granizada\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Rocio\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Chocolate blanco\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Kinotos al whiskey\"</span></code></pre></div>\n<p>Â¿PodrÃ­amos usar la variable anÃ³nima del lado derecho del igual? <strong>No</strong>. La variable anÃ³nima es un <em>patrÃ³n</em>, no es un valor. Por eso es que pertenece al lado izquierdo del igual, no la saquemos de su hÃ¡bitat natural ğŸ˜Œ. <em>Â¿Pero quÃ© pasa si no me importa nada y lo uso del lado derecho?</em> La respuesta es: ğŸ¦† en el parcial.</p>\n<p>Algo muy importante que no hay que olvidar es que Haskell va a leer de arriba a abajo todos los casos de <em>matcheo</em>, asÃ­ que si repetimos un nombre no solo nos va a decir que hay un caso que se repite (con las guardas no pasaba), sino que tambiÃ©n nos va a devolver lo que diga el primero de ambos:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Crema americana\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"SambayÃ³n\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Marcelo\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Menta granizada\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Frambuesa\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"Rocio\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Chocolate blanco\"</span>\n<span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Kinotos al whiskey\"</span>\n\n<span class=\"token operator\">></span> <span class=\"token hvariable\">gustoDeHelado</span> <span class=\"token string\">\"GastÃ³n\"</span>\n<span class=\"token string\">\"Crema americana\"</span></code></pre></div>\n<p>Tampoco deberÃ­amos agregar casos despuÃ©s del de la variable anÃ³nima porque nunca podremos llegar a ellos ya que recordemos que representa a <em>lo demÃ¡s que no apareciÃ³ antes</em>. AsÃ­ que como en las guardas, el <strong>orden importa</strong>. ğŸ˜‰ Â¡Y tambiÃ©n todos los casos deben devolver algo del mismo tipo de dato!</p>\n<p>Volvamos al tema de los patrones y valores:</p>\n<p>Existen 3 mundos de haskell: los <em>valores</em>, los <em>tipos</em> y los <em>patrones</em>. Y no se mezclan entre sÃ­.\nEntonces, â€œmochilaâ€, Â¿quÃ© es? Claramente no es un tipo ğŸ˜… asÃ­ que es un valorâ€¦ Â¿Â¡ o un patrÃ³n!? ğŸ˜•\nVa a depender quÃ© sea segÃºn <em>donde lo escribamos en el cÃ³digo</em>.</p>\n<p>AcÃ¡, que estÃ¡ al lado izquierdo del <code class=\"language-text\">=</code>,  es un patrÃ³n:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">cosasParaLaEscuela</span> <span class=\"token string\">\"mochila\"</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span></code></pre></div>\n<p>AcÃ¡, que estÃ¡ al lado derecho del <code class=\"language-text\">=</code>, es un valor:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">loMasNecesarioPara</span> <span class=\"token string\">\"Priscila\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"mochila\"</span></code></pre></div>\n<h6 id=\"patternmatcheando-listas\"><a href=\"#patternmatcheando-listas\" aria-label=\"patternmatcheando listas permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>PatternMatcheando listas</h6>\n<p>Â¡AsÃ­ es! Como vimos tambiÃ©n podemos matchear listas. ğŸ‰ Para eso utilizamos los siguientes patrones:</p>\n<ul>\n<li><code class=\"language-text\">[]</code> para la lista vacÃ­a;</li>\n<li><code class=\"language-text\">(cabeza:cola)</code> para la lista con al menos un elemento;</li>\n<li><code class=\"language-text\">(x:y:xs)</code> para una lista como al menos dos elementos.</li>\n</ul>\n<p>Con todo lo que sabemos ahora pudimos definir funciones que ya conocÃ­amos de listas:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">null</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token builtin\">null</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n<span class=\"token builtin\">null</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">False</span>\n\n<span class=\"token builtin\">head</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">head</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token builtin\">tail</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span>\n<span class=\"token builtin\">tail</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<h2 id=\"tuplas\"><a href=\"#tuplas\" aria-label=\"tuplas permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tuplas</h2>\n<p>Hasta ahora venÃ­amos trabajando con tipos de datos â€œsueltosâ€. La Ãºnica forma que conocÃ­amos de â€œagruparâ€ valores eran las listas, pero las mismas tienen una restricciÃ³n bastante fuerte: todos los elementos tienen que ser del mismo tipo. ğŸ˜”\nEntonces, Â¿cÃ³mo hacemos si queremos modelar a una persona con su nombre (un <code class=\"language-text\">String</code>) y una edad (un <code class=\"language-text\">Int</code>)? Usamos las <strong>tuplas</strong>. ğŸ˜ Pero ojo ğŸ‘€ que su cantidad de elementos no puede variar como en las listas. Si decidimos que sÃ³lo va a contener, por ejemplo, dos elementos, no se van a poder agregar mÃ¡s en el futuro.</p>\n<p>Algunas funciones que podemos usar con <em>duplas</em> (tuplas de dos elementos) son:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">fst</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n\n<span class=\"token operator\">></span> <span class=\"token builtin\">fst</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hola\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token number\">1</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">snd</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n\n<span class=\"token operator\">></span> <span class=\"token builtin\">snd</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Hola\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token string\">\"Hola\"</span></code></pre></div>\n<p>Antes de seguir con las tuplas, veamos algo para hacer nuestro cÃ³digo mÃ¡s expresivo: <strong>type alias</strong> o <strong>alias de tipo</strong>. Â¿Para quÃ© sirven? Para definir nuestros propios nombres de tipo que sean sinÃ³nimo de otro tipo. Por ejemplo, <code class=\"language-text\">String</code> es un alias de <code class=\"language-text\">[Char]</code>.</p>\n<p>Â¡Genial! Tenemos todo lo necesario para poder modelar a una persona. ğŸ™†â€â™€ï¸</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Nombre</span> <span class=\"token operator\">=</span> <span class=\"token constant\">String</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Edad</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span>\n<span class=\"token comment\">-- para lograr mÃ¡s expresividad creamos los alias `Nombre`y `Edad` que serÃ¡n un `String` y un `Int` respectivamente.</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Nombre</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Edad</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">-- creamos un alias para poder representar a la persona como una tupla</span></code></pre></div>\n<p>Â¡Festejemos un cumpleaÃ±os! ğŸ‚ Hagamos la funciÃ³n <code class=\"language-text\">cumplirAÃ±os</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Nombre</span> <span class=\"token operator\">=</span> <span class=\"token constant\">String</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Edad</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Nombre</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Edad</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span>\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">nombre</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">edad</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">nombre</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">edad</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Usando pattern matching pudimos definir la funciÃ³n. Y vemos que el nombre no se usa asÃ­ que podemos sacarlo para poner la variable anÃ³nima, Â¿no? ğŸ˜„ Noooo. Â¿QuÃ© pasa si hacemos eso? EstarÃ­amos â€œperdiendoâ€ el nombre cuando recibimos la tupla y no podrÃ­amos ubicarlo en la nueva tupla que devolvemos.</p>\n<p>Otra forma de definir la funciÃ³n, sin pattern matching es.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Nombre</span> <span class=\"token operator\">=</span> <span class=\"token constant\">String</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Edad</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Nombre</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Edad</span><span class=\"token punctuation\">)</span>\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span>\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fst</span> <span class=\"token hvariable\">unaPersona</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">snd</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Â¿Y si ahora queremos representar a una persona con nombre, edad, peso y altura? Vamos a tener esta tupla:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Float</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Float</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Â¿Y solo queremos saber el nombre de la persona? Â¿O la edad? Â¿O el peso? Â¿O la altura? ğŸ¤” Para eso podemos usar pattern matching para devolver solo lo que necesitamos. A este tipo de funciones las llamamos <em>accessors</em>. ğŸ˜</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">nombre</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">nombre</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">unNombre</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unNombre</span>\n\n<span class=\"token hvariable\">edad</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">edad</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">edad</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">edad</span>\n\n<span class=\"token hvariable\">peso</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Float</span>\n<span class=\"token hvariable\">peso</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">peso</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">peso</span>\n\n<span class=\"token hvariable\">altura</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Float</span>\n<span class=\"token hvariable\">altura</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">_</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">altura</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">altura</span></code></pre></div>\n<p>En este caso pudimos usar a la variable anÃ³nima porque ignoramos datos que no necesitamos ya que no vamos a devolver una tupla con todos los elementos, sino solo el que nos interesa.</p>\n<p>Ahora que estamos cancheras y cancheros, modelemos un auto con su modelo y kilÃ³metros. ğŸš—</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Auto</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Mmmmm, Â¿lo podremos hacer cumplir aÃ±os? O sea, no deberÃ­a poder porque es un auto y <code class=\"language-text\">cumplirAÃ±os</code> recibe personasâ€¦ Veamos quÃ© pasa:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Auto</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span>\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">fst</span> <span class=\"token hvariable\">unaPersona</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">snd</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token operator\">></span> <span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Toyota Corolla\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token string\">\"Toyota Corolla\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10001</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Â¡Noooo! Â¿Â¡CÃ³mo es posible!? ğŸ˜©</p>\n<p>Lo que pasa es que tanto <code class=\"language-text\">Auto</code> como <code class=\"language-text\">Persona</code> no son tipos de datos, sino que son sinÃ³nimos de <code class=\"language-text\">(String, Int)</code>. AsÃ­ que <code class=\"language-text\">cumplirAÃ±os</code> va a funcionar con cualquier tupla que tenga ese tipo.</p>\n<p>Â¿Â¡Y cÃ³mo lo solucionamos!? ğŸ˜± Â¡Sigamos!</p>\n<h2 id=\"data\"><a href=\"#data\" aria-label=\"data permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Data</h2>\n<p>Lo que necesitamos para solucionar el problema anterior es poder restringir a <code class=\"language-text\">cumplirAÃ±os</code> para que funcione solo con personas. Para eso es que vamos a <em>crear nuestro propio tipo de dato</em> con <strong>Data</strong>.\nSu sintaxis es: <code class=\"language-text\">TipoACrear = Constructor Tipo1 Tipo2</code></p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Persona</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Int</span> \n\n<span class=\"token operator\">></span> <span class=\"token constant\">Pesona</span> <span class=\"token string\">\"Gonza\"</span> <span class=\"token number\">22</span></code></pre></div>\n<p>Y para tener mÃ¡s expresividad podemos combinar data con type alias:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Nombre</span> <span class=\"token operator\">=</span> <span class=\"token constant\">String</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">Edad</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Int</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Persona</span> <span class=\"token constant\">Nombre</span> <span class=\"token constant\">Edad</span></code></pre></div>\n<p>Â¿CuÃ¡l es la diferencia con lo que hacÃ­amos? Antes tenÃ­amos una tupla que contenÃ­a un <code class=\"language-text\">String</code> que representaba al nombre de la persona y un <code class=\"language-text\">Int</code> que representaba la edad de la persona. A esa tupla le pusimos como alias <code class=\"language-text\">Persona</code> pero nunca, nunca, creamos un tipo de dato. Ahora con data sÃ­ lo estamos haciendo.</p>\n<p>Otra forma de crear un data es asÃ­:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Persona</span> <span class=\"token punctuation\">{</span><span class=\"token hvariable\">nombre</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">edad</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span></code></pre></div>\n<p>Â¡Y asÃ­ obtenemos accessors gratis! ğŸ˜œ Porque tanto <code class=\"language-text\">nombre</code> como <code class=\"language-text\">edad</code> son funciones que nos van a permitir acceder a esos campos del data.</p>\n<p>Â¿Por quÃ© agregamos el <code class=\"language-text\">deriving Show</code>? ğŸ’­ Porque esa es la forma que tenemos para decirle a Haskell que <code class=\"language-text\">Persona</code> va a pertenecer a la clase de tipo <code class=\"language-text\">Show</code> y va a poder mostrarse.</p>\n<p>Entonces, asÃ­ como creamos el tipo de dato <code class=\"language-text\">Persona</code>, creemos el tipo de dato <code class=\"language-text\">Auto</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Auto</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Persona</span> <span class=\"token punctuation\">{</span><span class=\"token hvariable\">modelo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">kilometros</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span></code></pre></div>\n<p>Teniendo los dos tipos de dato creados, probemos la funciÃ³n <code class=\"language-text\">cumplirAÃ±os</code> que ahora no recibe una persona representada como una tupla sino el <em>tipo de dato</em> <code class=\"language-text\">Persona</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Persona</span> <span class=\"token punctuation\">{</span><span class=\"token hvariable\">nombre</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">edad</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span>\n\n<span class=\"token keyword\">data</span> <span class=\"token constant\">Auto</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Persona</span> <span class=\"token punctuation\">{</span><span class=\"token hvariable\">modelo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">kilometros</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span>\n\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span>\n<span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token punctuation\">{</span><span class=\"token hvariable\">edad</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">edad</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">unaPersona</span><span class=\"token punctuation\">}</span>\n<span class=\"token comment\">-- estoy modificando el campo edad. Para eso necesito la edad de la persona (que la obtengo usando el accessor (una funciÃ³n) `edad`) y la compongo con `(+1)` para aplicÃ¡rselo a `unaPersona`.</span>\n\n<span class=\"token operator\">></span> <span class=\"token hvariable\">cumplirA</span>Ã±<span class=\"token hvariable\">os</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Auto</span> <span class=\"token string\">\"Toyota Corolla\"</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">)</span>\nğŸ’¥\n<span class=\"token comment\">-- porque ahora cumplirAÃ±os recibe al tipo Persona y le pasamos algo del tipo Auto.</span></code></pre></div>\n<h2 id=\"git\"><a href=\"#git\" aria-label=\"git permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Git</h2>\n<p>Todo lo que necesitÃ¡s saber estÃ¡ <a href=\"https://docs.google.com/document/d/147cqUY86wWVoJ86Ce0NoX1R78CwoCOGZtF7RugUvzFg/edit#heading=h.pfzudah6sze2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">acÃ¡</a> y en el <a href=\"https://mumuki.io/pdep-utn/chapters/309-control-de-versiones\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">capÃ­tulo 4 de Mumuki</a>. ğŸ‰\nY obvio que si te quedan dudas podÃ©s consultarlas con tu tutora o tutor. ğŸŒˆ</p>\n<h2 id=\"links-Ãºtiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links Ãºtiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links Ãštiles</h2>\n<ul>\n<li><a href=\"http://wiki.uqbar.org/wiki/articles/pattern-matching-en-haskell.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Pattern Matching</a></li>\n<li><a href=\"http://wiki.uqbar.org/wiki/articles/data--definiendo-nuestros-tipos-en-haskell.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tuplas, Typeclasses y Data</a></li>\n</ul>","frontmatter":{"title":"Quinta clase","date":"15-04-2019","description":"Pattern Matching, Tuplas y Git","tags":["funcional","pattern-matching","tuplas","git"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/funcional/clase-05/","previous":{"fields":{"slug":"/funcional/clase-04/"},"frontmatter":{"title":"Cuarta clase"}},"next":{"fields":{"slug":"/funcional/clase-06/"},"frontmatter":{"title":"Sexta clase"}}}}}