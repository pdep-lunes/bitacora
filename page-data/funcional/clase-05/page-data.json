{"componentChunkName":"component---src-templates-blog-post-js","path":"/funcional/clase-05/","webpackCompilationHash":"5b3f2876a3fece0e40c0","result":{"data":{"site":{"siteMetadata":{"title":"Bitácora","author":"pdep"}},"markdownRemark":{"id":"fad8042d-4ee3-5cf7-9f4e-9da53b6b3970","excerpt":"¿Qué vimos hoy? Volvimos al TT de la clase pasada TP “Hora de lectura” para hacer nuevos ejercicios dentro del mismo dominio. Arrancamos con guardas, mostrando…","html":"<h2 id=\"¿qué-vimos-hoy\"><a href=\"#%C2%BFqu%C3%A9-vimos-hoy\" aria-label=\"¿qué vimos hoy permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Qué vimos hoy?</h2>\n<p>Volvimos al TT de la clase pasada <a href=\"https://docs.google.com/document/d/11uYGXvG-TnNhveawDjKD1iSWKW9Qy8PVqlvtHhV58F8/edit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TP “Hora de lectura”</a> para hacer nuevos ejercicios dentro del mismo dominio.</p>\n<p>Arrancamos con <strong>guardas</strong>, mostrando cuando <strong>NO</strong> queríamos usar guardas y ahora vamos a ver cuando sí.</p>\n<p>Vamos a modelar el género de un libro:</p>\n<ul>\n<li>Si tiene menos de 50 páginas, es un cómic.</li>\n<li>Si el autor es Stephen King, es de terror.</li>\n<li>Si el autor es japonés, es un manga.</li>\n<li>En cualquier otro caso, no sabemos el género.</li>\n</ul>\n<p>Deberíamos agregar la nacionalidad al conjunto de autores? Lo único que necesitamos para este caso es saber si es japones.</p>\n<p>Cómo modelamos la función genero? Arranquemos con el tipo:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genero</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span></code></pre></div>\n<p>¿Por qué no se puede resolver por pattern matching?\nSe pregunta si Pattern matching solo se usa para booleanos, y se muestra por ejemplo en los accessors que no. Con pattern matching podemos devolver cualquier tipo de dato!</p>\n<p>Usamos pattern matching cuando tenemos algo que encaja con un patrón, por ejemplo una tupla de 3 elementos, una lista vacía, etc.\nUsamos guardas cuando queremos evaluar conjuntos de dominios (en matemática, esto es muy similar a las funciones partidas).</p>\n<p>Volvamos al ejercicio:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genero</span> <span class=\"token hvariable\">unLibro</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">></span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">cantidadDePaginas</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Comic\"</span>\n  <span class=\"token operator\">|</span> <span class=\"token hvariable\">esDe</span> <span class=\"token string\">\"Stephen King\"</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Terror\"</span>\n  <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">esJapones</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">autor</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Manga\"</span>\n  <span class=\"token operator\">|</span> <span class=\"token builtin\">otherwise</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"No clasificado\"</span></code></pre></div>\n<p>Construimos la función auxiliar <code class=\"language-text\">esJapones</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">esJapones</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">esJapones</span> <span class=\"token string\">\"Hajime Isayama\"</span> <span class=\"token operator\">=</span> <span class=\"token constant\">True</span>\n<span class=\"token hvariable\">esJapones</span> <span class=\"token hvariable\">_</span> <span class=\"token operator\">=</span> <span class=\"token constant\">False</span></code></pre></div>\n<p>Por qué en el conjunto <code class=\"language-text\">otherwise</code> entra todo el resto del dominio abarcado? Resulta que <code class=\"language-text\">otherwise</code> es nada más que un sinónimo de <code class=\"language-text\">True</code>! Utilizamos <code class=\"language-text\">otherwise</code> para ser más expresivos.</p>\n<p>Ahora volvamos a los tipos de datos. ¿Qué pasa si uso género y le paso otra tupla? Vamos a probar con una tupla Persona, por ejemplo (“Gustavo”, “Trucco”, 28):</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">genero</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Gustavo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Trucco\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">28</span><span class=\"token punctuation\">)</span>\n<span class=\"token operator\">></span> <span class=\"token string\">\"Comic\"</span></code></pre></div>\n<p>Al usar una tupla del tipo <code class=\"language-text\">(String, String, Int)</code>, si bien no es un libro, podemos utilizar la función <code class=\"language-text\">género</code> ya que este tipo coincide con el tipo de libro. Recordemos que al usar <code class=\"language-text\">type alias</code> estamos siendo más expresivos pero no estamos haciendo una validación para ese tipo de dato. Para resolver este problema, introducimos el concepto de <code class=\"language-text\">data</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">=</span> <span class=\"token constant\">UnLibro</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Autor</span> <span class=\"token constant\">Int</span></code></pre></div>\n<p><code class=\"language-text\">UnLibro</code> es una función que llamamos <code class=\"language-text\">constructor</code>. ¿Cuál es el tipo de <code class=\"language-text\">UnLibro</code>?</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token constant\">UnLibro</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Autor</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span></code></pre></div>\n<p>Podemos ver que la función recibe los parámetros que necesitamos para crear al libro. Vamos a modelar “El visitante”:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token constant\">UnLibro</span> <span class=\"token string\">\"El visitante\"</span> <span class=\"token string\">\"Stephen King\"</span> <span class=\"token number\">592</span></code></pre></div>\n<p>Si probamos esto en la consola de Haskell, no vamos a poder ver el libro ya que nuestro data no es mostrable. ¿Qué significa esto? Haskell no sabe cómo mostrar nuestro tipo de dato. Esto lo podemos resolver utilizando <code class=\"language-text\">deriving Show</code> al final de la declaración del data:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">=</span> <span class=\"token constant\">UnLibro</span> <span class=\"token constant\">String</span> <span class=\"token constant\">Autor</span> <span class=\"token constant\">Int</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span></code></pre></div>\n<p>Hasta acá, <code class=\"language-text\">data</code> parece ser más complejo que usar tuplas. ¿Qué ventajas nos está dando? Como dijimos antes, con los <code class=\"language-text\">type alias</code> no estábamos creando un tipo de dato. Utilizando <code class=\"language-text\">data</code> podemos validar estrictamente los tipos de las funciones que modelamos. Antes pudimos usar la función <code class=\"language-text\">genero</code> para humanos y no queríamos poder hacer eso. Ahora con <code class=\"language-text\">data</code> podemos hacer que la función <code class=\"language-text\">genero</code> solamente pueda recibir libros.</p>\n<p>Además, podemos utilizar <code class=\"language-text\">record syntax</code> con data y tenemos los accessors!</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">=</span> <span class=\"token constant\">UnLibro</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">titulo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">autor</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Autor</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">deriving</span> <span class=\"token constant\">Show</span></code></pre></div>\n<p>Acá podemos ver que los accessors son nada más y nada menos que funciones! Miremos por ejemplo el tipo de titulo:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">titulo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span></code></pre></div>\n<p>Ambas sintaxis para definir datas son equivalentes, solo que la record syntax nos regala las funciones para acceder a las propiedades.</p>\n<p>Por otro lado, si queremos comparar una instancia de data con otra, tenemos que decirle a haskell que queremos que sean comparables. Cómo hacemos eso? Utilizando <code class=\"language-text\">Eq</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">=</span> <span class=\"token constant\">UnLibro</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">titulo</span> <span class=\"token operator\">::</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">autor</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Autor</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">deriving</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Show</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Eq</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Ahora vamos a modelar la función <code class=\"language-text\">agregarPaginas</code>. Esta función va a modificar al libro original? ¡No! Los data, al igual que todo en funcional, siguen siendo inmutables. Por ende, la función nos devolverá una copia del libro con la cantidad de páginas aumentada.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">agregarPaginas</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">agregarPaginas</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">UnLibro</span> <span class=\"token hvariable\">unTitulo</span> <span class=\"token hvariable\">unAutor</span> <span class=\"token hvariable\">unaCantidadDePaginas</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">paginasAAgregar</span> <span class=\"token operator\">=</span> <span class=\"token constant\">UnLibro</span> <span class=\"token hvariable\">unTitulo</span> <span class=\"token hvariable\">unAutor</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">unaCantidadDePaginas</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">paginasAAgregar</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Podemos hacer lo mismo con la record syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">agregarPaginas</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">agregarPaginas</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token hvariable\">paginasAAgregar</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">+</span>  <span class=\"token hvariable\">paginasAAgregar</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>Es importante destacar que para devolver la nueva cantidad de paginas debemos sumar la cantidad de paginas original. Para eso, utilizamos el accessor <code class=\"language-text\">cantidadDePaginas</code> y es importante pasarle por parámetro <code class=\"language-text\">unLibro</code> para que pueda darnos el valor. <code class=\"language-text\">cantidadDePaginas</code> sigue siendo una función que necesita su parámetro.</p>\n<p>Para que quede aclaro, hagamos otro ejemplo. Modelemos <code class=\"language-text\">sacarSecuela</code>, que agrega un “2” al final del título y cuyas páginas siempre serán 400.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sacarSecuela</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">sacarSecuela</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token operator\">=</span> <span class=\"token number\">400</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">titulo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span> <span class=\"token string\">\" 2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token hvariable\">titulo</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ahora, tenemos una repetición de lógica en ambas funciones. En ambas estamos cambiando las páginas de alguna forma. ¿Podemos abstraer esa lógica? Claro que sí! Modelemos la función <code class=\"language-text\">cambiarCantidadDePaginas</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">cambiarCantidadDePaginas</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">cambiarCantidadDePaginas</span> <span class=\"token hvariable\">unaFuncion</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unaFuncion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cantidadDePaginas</span> <span class=\"token hvariable\">unLibro</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Ahora la cantidad de páginas se cambia según una función recibida por parámetro (concepto de <em>órden superior</em>). Pero… en <code class=\"language-text\">sacarSecuela</code> no usabamos una función, asignabamos 400, ¿Cómo hacemos para utilizar la función? Podemos utilizar <code class=\"language-text\">const</code>, la cual recibe dos parámetros y siempre se queda con el primero.</p>\n<p>Ya que estamos, podemos abstraer el cambio de título de forma similar al cambio de cantidad de páginas:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">cambiarTitulo</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">cambiarTitulo</span> <span class=\"token hvariable\">unaFuncion</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">titulo</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">unaFuncion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">titulo</span> <span class=\"token hvariable\">unLibro</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Nuestras funciones quedarían:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">agregarPaginas</span>' <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">agregarPaginas</span>' <span class=\"token hvariable\">algunLibro</span> <span class=\"token hvariable\">paginasAAgregar</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">cambiarCantidadDePaginas</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">+</span> <span class=\"token hvariable\">paginasAAgregar</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">algunLibro</span>\n\n<span class=\"token hvariable\">sacarSecuela</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Libro</span>\n<span class=\"token hvariable\">sacarSecuela</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">cambiarCantidadDePaginas</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">const</span> <span class=\"token number\">400</span><span class=\"token punctuation\">)</span><span class=\"token operator\"> . </span><span class=\"token hvariable\">cambiarTitulo</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span> <span class=\"token string\">\" 2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">unLibro</span></code></pre></div>\n<p>Pasemos ahora a modelar a las personas. Las personas tienen un nombre y un conjunto de libros que le gustan:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Libro</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">gustos</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Libro</span><span class=\"token punctuation\">]</span>\n<span class=\"token hvariable\">gustos</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">snd</span> <span class=\"token hvariable\">unaPersona</span></code></pre></div>\n<p>Ahora queremos saber si a una persona le gusta un libro. Definimos la función <code class=\"language-text\">leGusta</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">leGusta</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">leGusta</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span> <span class=\"token hvariable\">unLibro</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gustos</span> <span class=\"token hvariable\">unaPersona</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>De esta forma asumimos que a una persona siempre le gustan algunos libros. Ahora hagamos un cambio al modelado. En vez de tener los libros que le gustan a la persona, definamos un criterio por el cual a una persona le gusta un libro:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">String</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">julian</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Persona</span>\n<span class=\"token hvariable\">julian</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Julian\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">esLibroLigero</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">esLibroFantasioso</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">esDe</span> <span class=\"token string\">\"Stephen King\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Y ahora nuestra función leGusta quedaría:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">leGusta</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">leGusta</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">leGustaSegun</span> <span class=\"token hvariable\">unLibro</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gustos</span> <span class=\"token hvariable\">unaPersona</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token hvariable\">leGustaSegun</span> <span class=\"token operator\">::</span>  <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span>         <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">leGustaSegun</span>    <span class=\"token hvariable\">unLibro</span>       <span class=\"token hvariable\">unGusto</span>     <span class=\"token operator\">=</span>     <span class=\"token hvariable\">unGusto</span> <span class=\"token hvariable\">unLibro</span></code></pre></div>\n<p>Que nos pasa con la función <code class=\"language-text\">leGustaSegún</code>? No tiene demasiada lógica, y además es dificil encontrar un nombre expresivo para esta función auxiliar. Para eso, dentro de haskell contamos con las expresiones Lambda: funciones que no necesitamos nombrar y que usamos para este tipo de casos particulares. Reescribamos la función <code class=\"language-text\">leGusta</code> utilizando lambda:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">leGusta</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Libro</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Persona</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token hvariable\">leGusta</span> <span class=\"token hvariable\">unLibro</span> <span class=\"token hvariable\">unaPersona</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">any</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">\\</span><span class=\"token hvariable\">unGusto</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">unGusto</span> <span class=\"token hvariable\">unLibro</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">gustos</span> <span class=\"token hvariable\">unaPersona</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>La lambda está definida entre paréntesis. En este caso recibe un solo parámetro, pero podría recibir varios. La <code class=\"language-text\">-&gt;</code> indica dónde terminan los parámetros y empieza la función. Las expresiones lambda o funciones anónimas nos sirven para este tipo de casos específicos.</p>\n<h2 id=\"links-útiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links útiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links Útiles</h2>\n<ul>\n<li>\n<p><a href=\"https://gist.github.com/julian-berbel/902aa2942c210c2dbeef3adcf9ec147b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Solución del ejercicio de hoy</a></p>\n<!-- - [Video de la clase](completar) -->\n</li>\n</ul>\n<h2 id=\"tarea-para-la-clase-que-viene\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene:</h2>\n<!-- - Leer apunte de [git](completar) -->\n<ul>\n<li>Realizar el <a href=\"https://docs.google.com/document/d/1EAN_RC2zngF1jiy4MGCuLvYQvr1euHj1Xx4ORiDh-nE/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TP</a> y entregarlo por github</li>\n<li>(Opcional) Hacer las guías de Mumuki de <a href=\"https://mumuki.io/pdep-utn/lessons/743-programacion-funcional-expresiones-lambda\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Lambda</a>, <a href=\"https://mumuki.io/pdep-utn/lessons/745-programacion-funcional-modelado\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Data</a> y <a href=\"https://mumuki.io/pdep-utn/chapters/438-control-de-versiones\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">uso de consola y git</a>.</li>\n</ul>","frontmatter":{"title":"Quinta clase","date":"04-05-2020","description":"Quinta clase de PdeP","tags":["funcional","data","expresiones-lambda"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/funcional/clase-05/","previous":{"fields":{"slug":"/funcional/clase-04/"},"frontmatter":{"title":"Cuarta clase"}},"next":null}}}