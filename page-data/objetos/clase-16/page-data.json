{"componentChunkName":"component---src-templates-blog-post-js","path":"/objetos/clase-16/","webpackCompilationHash":"2cdcd56d4050c0417b9b","result":{"data":{"site":{"siteMetadata":{"title":"Bitácora","author":"pdep"}},"markdownRemark":{"id":"c83b1ab1-7970-5573-a312-f3a58e8ac134","excerpt":"Tarea para la clase que viene: Entrega 2 del TP cuatrimestral de objetos. Herencia Anteriormente vimos que cuando dos objetos repiten lógica, crear una clase…","html":"<h2 id=\"tarea-para-la-clase-que-viene\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene:</h2>\n<ul>\n<li>Entrega 2 del TP cuatrimestral de objetos.</li>\n</ul>\n<h2 id=\"herencia\"><a href=\"#herencia\" aria-label=\"herencia permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Herencia</h2>\n<p>Anteriormente vimos que cuando dos objetos repiten lógica, crear una clase puede que sea nuestra solución. Pero, ¿qué hacemos cuando dos clases repiten lógica? Esto es un trabajo para… ¡la superclase! 🦸‍♀️🦸‍♂️</p>\n<p>Al tener lógica repetida entre clases podemos crear una nueva clase con esa lógica, dejando en cada una de las clases iniciales sólo lo particular de cada una. </p>\n<p>Por ejemplo:</p>\n<p><em>Los perros y los gatos al jugar pierden unidades de energía según el tiempo que reciben por parámetro. Al pedirles que emitan un sonido los perros hacen guau (sí, todo muy original) y los gatos… ¡MUUU! 😲 (no, mentira, hacen miau pero casi se la creen 😂).\nPero al llegar su dueño o dueña a casa actúan distinto. Los gatos 🐈 actúan con indiferencia, es decir, no hacen nada. Los perros 🐕 en cambio aumentan en 100 su energía.</em></p>\n<p>Un código posible podría ser:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Gato {\n\tvar energia\n\t\n\tmethod jugar(unTiempo) {\n\t\tenergia -= unTiempo\n\t}\n\n\tmethod emitirSonido() {\n\t\treturn &quot;miau&quot;\n\t}\n\n\tmethod recibirDueño() {\n\t}\n}\n\nclass Perro {\n\tvar energia\n\t\n\tmethod jugar(unTiempo) {\n\t\tenergia -= unTiempo\n\t}\n\n\tmethod emitirSonido() {\n\t\treturn &quot;guau&quot;\n\t}\n\n\tmethod recibirDueño() {\n\t\tenergia += 100\n\t}\n}</code></pre></div>\n<p>¿Esa lógica repetida no les hizo doler los ojos? 😵</p>\n<p>Una solución sería crear una clase Animal (no es una frase onda “CREA UNA CLASE ANIMAL!!! MÁQUINA!!! 💪”) que contenga la lógica repetida:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Animal {\n\tvar energia\n\tvar sonido\n\t\n\tmethod jugar(unTiempo) {\n\t\tenergia -= unTiempo\n\t}\n\n\tmethod emitirSonido() {\n\t\treturn sonido\n\t}\n}</code></pre></div>\n<p>Lo único que faltaría es establecer una relación entre esta nueva clase y las originales definiendo <strong>herencia</strong> de la siguiente manera: 👇</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Perro inherits Animal {\n\tvar sonido = &quot;guau&quot;\n\t\n\tmethod recibirDueño() {\n\t\tenergia += 100\n\t}\n}\n\nclass Gato inherits Animal {\n\tvar sonido = &quot;miau&quot;\n\t\n\tmethod recibirDueño() { \n\t}\n}</code></pre></div>\n<p>Listo, ¡problema solucionado! 🙌 Ahora vamos a decir que <code class=\"language-text\">Animal</code> es la <strong>superclase</strong> de <code class=\"language-text\">Perro</code> y <code class=\"language-text\">Gato</code> o, de otra manera, que <code class=\"language-text\">Perro</code> y <code class=\"language-text\">Gato</code> son <strong>subclases</strong> de <code class=\"language-text\">Animal</code>. Hay que tener en cuenta que cada clase solo puede heredar de una y solo una clase.</p>\n<h2 id=\"super\"><a href=\"#super\" aria-label=\"super permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Super</h2>\n<p>Siguiendo con nuestro ejemplo, imaginémonos que aparece la clase <code class=\"language-text\">Gallina</code> 🐔, cada <code class=\"language-text\">Gallina</code> emite el sonido “A River lo sigo a donde va” y cuando juegan también pierde energia, peeero también ponen un huevo 🐣. Entonces tendríamos que redefinir el método <code class=\"language-text\">jugar</code>, pero teniendo en cuenta que una parte de la lógica ya está definida en la superclase <code class=\"language-text\">Animal</code>. Para hacer esto vamos a combinar <code class=\"language-text\">override</code> (para redefinir un método de la superclase) con <code class=\"language-text\">super</code> (para ver que hace la superclase):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Gallina inherits Animal {\n\tvar sonido = &quot;A River lo sigo a donde va&quot;\n\tvar huevosPuestos = 0\n\n\toverride method jugar(unTiempo) {\n\t\tsuper(unTiempo)\n\t\thuevosPuestos ++\n\t}\n}</code></pre></div>\n<h2 id=\"redefinición\"><a href=\"#redefinici%C3%B3n\" aria-label=\"redefinición permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redefinición</h2>\n<p>Acá vemos que la <code class=\"language-text\">Gallina</code> no tiene el método <code class=\"language-text\">recibirDueño</code>, ¿debería? 🤔</p>\n<p>Esto es una decisión de nuestro diseño, si creemos que todos los animales deberían poder recibir dueños (que los animales deban obligatoriamente tener dueños pertenece a un debate que no vamos a tener, recordemos que esto es meramente un ejemplo), debería estar presente en nuestro código. ¿Pero qué hace un animal cualquiera al recibir a su dueño? ¿Hay alguna lógica en común entre todos los animales? ¿Qué escribo en la superclase?</p>\n<p>Claramente no conocemos un comportamiento genérico para todos los animales, pero si queremos que todos los animales sepan recibir a su dueño sin especificar una lógica podemos crear un <strong>método abstracto</strong> escribiendo solo la <strong>firma</strong> de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Animal {\n\t….\n\tmethod recibirDueño()\n\t….\n}</code></pre></div>\n<p>❗ ❗ Es importante diferenciar <code class=\"language-text\">recibirDueño()</code> de <code class=\"language-text\">recibirDueño() { }</code>. El segundo no es un método abstracto sino un método vacío. Aquellas clases que tienen métodos abstractos son llamadas <strong>clases abstractas</strong> y tienen la particularidad de que no pueden ser instanciadas. En nuestro ejemplo podemos tener gallinas, gatos y perros pero no animales a secas.</p>\n<p>Luego de hacer esto es importante redefinir el método en cada subclase con la palabra <code class=\"language-text\">override</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Perro inherits Animal {\n\tvar sonido = &quot;guau&quot;\n\t\n\toverride method recibirDueño() {\n\t\tenergia += 100\n\t}\n}\n\nclass Gato inherits Animal {\n\tvar sonido = &quot;miau&quot;\n\t\n\toverride method recibirDueño() { \n\t}\n}\n\nclass Gallina inherits Animal {\n\tvar sonido = &quot;A River lo sigo a donde va&quot;\n\tvar huevosPuestos = 0\n\n\toverride method jugar(unTiempo) {\n\t\tsuper(unTiempo)\n\t\thuevosPuestos ++\n\t}\n\n\toverride method recibirDueño() { \n\t\thuevosPuestos = 0 /* el dueño llega y le roba los huevos*/\n\t}\n}</code></pre></div>\n<h2 id=\"method-lookup\"><a href=\"#method-lookup\" aria-label=\"method lookup permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Method lookup</h2>\n<p>Hasta ahora vimos que cuando le enviamos un mensaje a un <strong>well known object</strong> busca el método en la definición de ese objeto 🔎. Si se lo enviamos a una <strong>instancia</strong>, lo busca en la clase a la que pertenece. Esto sigue siendo correcto, pero también aprendimos que si el método no está definido en la clase de la cual el objeto es instancia buscará en la superclase, y en caso que no esté seguirá buscando “para arriba” en la jerarquía de clases 🕵️‍♀️🕵️‍♂️. En caso que la superclase más super de todas, es decir, la clase <code class=\"language-text\">Object</code> no defina ese método obtendremos el famoso error <code class=\"language-text\">wollok.lang.MessageNotUnderstoodException</code>.</p>\n<h2 id=\"diagrama-de-clases\"><a href=\"#diagrama-de-clases\" aria-label=\"diagrama de clases permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Diagrama de clases</h2>\n<p>El diagrama de clases es una herramienta que nos permite modelar nuestra solución a partir de un esquema. En el mismo encontraremos las clases, objetos e interfaces (aún no vieron este tema), sus atributos, sus métodos y cómo se relacionan estos componentes. Es una manera de representar nuestras soluciones más allá del código.</p>\n<p>En esta clase en particular vimos cómo representar clases concretas, clases abstractas, objetos y las flechas de “hereda de” y “tiene”.</p>\n<h2 id=\"links-útiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links útiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links útiles</h2>\n<ul>\n<li><a href=\"https://drive.google.com/file/d/1DHstVgBAM4rVCH2kNAC9zwWXoCJdkazb/view\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Video de la clase</a></li>\n<li><a href=\"https://github.com/pdep-lunes/clase16-objetos-2020\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Código de la clase</a></li>\n<li><a href=\"http://www.plantuml.com/plantuml/png/ZL5DJy9043splwBXr1fxq1z0842CYGI3mVlGZhXakukpirpG_-uiz4DBWbxQ-PWtR-UziMSW3fLHaurdWeAJPoJlBEmmEIgqI5iDIji3MfdKJcr9ivlXgoxOaRG6_KgQDJ29M4iyRrCJYdUWgRD2bU97q7kNgJrIYTGC5M1Pbr1cgebcE3TO2R_piY8OrfLhAbAGBGoqxfKJLO5rauLyQZh7v9uYV-aeKrzAJGrutvsxV4FhzS4bnmkekGARuGkOK7PYJLPO1Ba9w3zxfgxQ0AF0ptBSrVzxLPmwcjAea44GXPWm3NP-6hXDua7dEAj13s3Z-iw1Sxl5P68auvP0ldu1VeLUUyQODMuCBfucoX8S_tv3KXkvjeyjISSSroutEomuOKSYydL_BcqMV0Jc-UUerLxrpUkr-oRzxlwyBtRglAdd-MXuC-p6nsZBK9bl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Diagrama de clases de la clase</a></li>\n<li><a href=\"https://github.com/pdep-noche-mavi/tutorial-plantuml\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Instructivo Plant UML</a></li>\n<li><a href=\"https://docs.google.com/document/d/1KdG7NrKPgPh4bAcyLuDG2G1iWP7Ze2GFs91qzlvDKqI/edit#heading=h.mpvsrdz55x8g\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Herencia, super, redinifición y method lookup en Wollok</a></li>\n</ul>","frontmatter":{"title":"Dieciseisava clase","date":"05-10-2020","description":"Dieciseisava clase de PdeP","tags":["herencia","super","clases abstractas","redefinición","diagrama de clases"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/objetos/clase-16/","previous":{"fields":{"slug":"/objetos/clase-15/"},"frontmatter":{"title":"Quinceava clase"}},"next":null}}}