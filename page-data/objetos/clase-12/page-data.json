{"componentChunkName":"component---src-templates-blog-post-js","path":"/objetos/clase-12/","webpackCompilationHash":"b20210ae7728d3e02992","result":{"data":{"site":{"siteMetadata":{"title":"Bitácora","author":"pdep"}},"markdownRemark":{"id":"8305f99b-1fb6-5ede-bd8f-cba6a8129ff6","excerpt":"¿Qué vimos hoy? Identidad vs Igualdad : decimos que dos objetos son idénticos si son el mismo objeto. Dentro del ambiente podemos tener dos referencias…","html":"<h2 id=\"¿qué-vimos-hoy\"><a href=\"#%C2%BFqu%C3%A9-vimos-hoy\" aria-label=\"¿qué vimos hoy permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>¿Qué vimos hoy?</h2>\n<p>Identidad vs Igualdad</p>\n<p><code class=\"language-text\">Identidad</code>: decimos que dos objetos son idénticos si son el mismo objeto. Dentro del ambiente podemos tener dos referencias diferentes al mismo objeto. En Wollok el operador usado para comparar dos objetos por identidad es ===.</p>\n<p><code class=\"language-text\">Igualdad</code>: (o equivalencia) por defecto dos objetos son iguales si son idénticos, o sea si son el mismo objeto. Al mismo tiempo dos objetos que no son idénticos pueden ser iguales. La igualdad == puede ser redefinida para que funcione acorde a nuestro dominio.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object lanzamientoWindows98 {\n\tconst property dia = 25\n\tconst property mes = 6\n\tconst property anio = 1998\n\t\n\toverride method ==(otroDia) {\n\t\treturn dia  == otroDia.dia()\n\t\t\t&amp;&amp; mes  == otroDia.mes()\n\t\t\t&amp;&amp; anio == otroDia.anio()\n\t}\n}\n\nobject fechaDeNacimiento {\n\tconst property dia = 25\n\tconst property mes = 6\n\tconst property anio = 1998\n\t\n\toverride method ==(otroDia) {\n\t\treturn dia  == otroDia.dia()\n\t\t\t&amp;&amp; mes  == otroDia.mes()\n\t\t\t&amp;&amp; anio == otroDia.anio()\n\t}\t\n}\n\n// Sin redefinir el ==\n&gt; lanzamientoWindows98 == fechaDeNacimiento // =&gt; false\n&gt; lanzamientoWindows98 === fechaDeNacimiento // =&gt; false\n\n// Redefiniendo el ==\n&gt; lanzamientoWindows98 == fechaDeNacimiento // =&gt; true\n&gt; lanzamientoWindows98 === fechaDeNacimiento // =&gt; false, siguen sin ser el mismo objeto</code></pre></div>\n<p>Para probar esto vamos a retomar el ejercicio anterior donde teníamos mascotas y personas que eran dueñas de mascotas. Vamos a introducir un par de cambios, vamos a hacer que los dueños puedan cambiar de mascota y que nos digan si pueden o no jugar con sus mascotas. Una persona puede jugar con su mascota siempre y cuando su energía esté por arriba de 100 y la mascota tenga más de 80 de energía.</p>\n<p>Si billy pasa a tener a sally como mascota vemos que en el diagrama tanto él como mandy “apuntan”/”conocen” a la misma mascota. Como ambos tienen a la misma mascota (el mismo objeto) lo que haga uno con esa mascota afecta a lo que pueda hacer el otro.</p>\n<p>Si billy juega dos veces con sally ahora mandy no puede jugar.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">billy.mascota(sally)\nbilly.jugarConMascota()\nbilly.jugarConMascota()\nmandy.puedeJugar() // =&gt; false</code></pre></div>\n<p>Realizamos el ejercicio <code class=\"language-text\">PDEPCargas</code> y vimos los siguientes conceptos:</p>\n<p>Self</p>\n<p>Empezando a realizar el objeto <code class=\"language-text\">camionDeGanado</code>, podríamos pensar esto como primera opción:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object camionGanado {\n  var kilometraje = 700000\n  var cantidadVacas = 10\n\n  method pesoCarga() = cantidadVacas * 600\n\n  method velocidadMaxima() = 80 - (cantidadVacas * 600) / 1000\n}</code></pre></div>\n<p>Esto nos presenta un problema: Tenemos una repetición de lógica entre <code class=\"language-text\">velocidadMaxima</code> y <code class=\"language-text\">pesoCarga</code>. ¿Cómo podríamos llamar a ese mensaje?</p>\n<p>una opción podría ser <code class=\"language-text\">camionGanado.pesoCarga()</code>, pero vemos que wollok nos indica un warning:</p>\n<p><code class=\"language-text\">Don’t use the name within the object. Use ‘self’ instead.</code></p>\n<p>Self es una manera con la cual el objeto se conoce a sí mismo. Con self, puedo enviar mensajes que entienda el propio objeto, para poder abstraer lógica repetida en otros métodos del mismo objeto. self es una referencia al mismo objeto.</p>\n<p>Esto, con self, se puede resolver de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object camionGanado {\n  var kilometraje = 700000\n  var cantidadVacas = 10\n\n  method pesoCarga() = cantidadVacas * 600\n\n  method velocidadMaxima() = 80 - self.pesoCarga() / 1000\n}</code></pre></div>\n<p>Hacemos el resto de los camiones, haciendo los métodos con las firmas necesarias (por ejemplo, <code class=\"language-text\">recorrerRuta</code> podría tener diferentes firmas y no estar en el <code class=\"language-text\">scannion5000</code>).</p>\n<p>Puesto rutatlántica</p>\n<p>Arrancando el puesto, podríamos hacer un primer approach:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object rutatlantica {\n  method pasar(unCamion) {\n    pdepCargas.cobrar(7000 + 100 * unCamion.pesoCarga() / 1000)\n    if (unCamion == camionGanado) {\n       unCamion.kilometraje(unCamion.kilometraje() + 400)\n    } else if (unCamion == camionCerealero) {\n       unCamion.nivelDeDeterioro(unCamion.nivelDeDeterioro() + 0.max(unCamion.velocidadMaxima().min(75) - 45))\n    }\n  }\n}</code></pre></div>\n<p>Hay un poco de ruido en esta solución: ¿Es necesario que comparemos camión por camión para saber qué lógica implementar? ¿Está bien que esta lógica la implemente el puesto? ¿Está bien que el puesto modifique el estado de los camiones?</p>\n<p>La respuesta, según el concepto <code class=\"language-text\">encapsulamiento</code>, es no.</p>\n<p>El <code class=\"language-text\">encapsulamiento</code> es la manera con la cual un objeto sólo usa lo que necesita de otro objeto para poder interactuar con éste. Es decir, utiliza la <code class=\"language-text\">interfaz</code> (mensajes que entiende) del objeto para interactuar con él. Cada objeto es responsable de su propio estado, y no el de otros.</p>\n<p>La <code class=\"language-text\">responsabilidad</code>, a nivel objetos, son las cosas que el objeto es responsable de hacer. Por ejemplo, el puesto rutatlantica en este caso NO es responsable de cambiar el kilometraje de los camiones, pero SI es responsable de cobrarle a pdepCargas una cantidad que debe calcular.</p>\n<p>Podríamos hacer un segundo approach:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object rutatlantica {\n  method pasar(unCamion) {\n    pdepCargas.cobrar(7000 + 100 * unCamion.pesoCarga() / 1000)\n    unCamion.recorrerRuta(400, unCamion.velocidadMaxima().min(75))\n  }\n}</code></pre></div>\n<p>Ahora vemos que le vamos a querer decir a un camión que recorra una ruta. ¿Esto funciona para todos los camiones que hicimos? ¿Qué pasa con la firma del método en los diferentes camiones? ¿Y si no definimos el método?</p>\n<p>¿Queremos que el método funcione para todos los camiones? Sí, ya que a todo camión que pase por el puesto se le debe mandar un mensaje para que recorra 400 kms y a 75 km/h como máximo.</p>\n<p>De esto surge el <code class=\"language-text\">polimorfismo</code>: Queremos que <code class=\"language-text\">recorrerRuta(kilometraje, velocidad)</code> lo entiendan todos los camiones, para que rutatlántica los pueda usar indistintamente. Es decir, el <code class=\"language-text\">polimorfismo</code> en objetos es la capacidad de que un objeto pueda utilizar indistintamente a otros objetos, siendo que potencialmente estos otros sean distintos. Con esto en mente, deberíamos cambiar el método <code class=\"language-text\">recorrerRuta</code> en todos los camiones:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object camionGanado {\n\tmethod recorrerRuta(extension, velocidad){\n\t\tkilometraje = kilometraje + extension\n\t}\n}\nobject scanion5000 {\n\tmethod recorrerRuta(extension, velocidad){\n\t\t// no hace nada\n\t}\n}\n\nobject camionCerealero {\n\n\tmethod recorrerRuta(extension, velocidad){\n\t\tnivelDeterioro += 0.max(velocidad - 45)\n\t}\n}</code></pre></div>\n<p>Veamos bien qué es lo que está haciendo el método pasar:</p>\n<ul>\n<li>Se encarga de realizar el cobro a pdepCargas</li>\n<li>Realiza el cálculo para saber cuánto hay que cobrarle</li>\n<li>Le dice a un camión que recorra una ruta</li>\n<li>Calcula la velocidad a la cual el camión debe de recorrer la ruta</li>\n</ul>\n<p>Dentro de estas cuatro cosas que está haciendo el método <code class=\"language-text\">pasar()</code>, ¿Es <code class=\"language-text\">responsable</code> el método de hacerlo todo? ¿A qué nos referimos por <code class=\"language-text\">responsable</code>?</p>\n<p>Nos referimos por <code class=\"language-text\">responsabilidad</code>, en métodos, a eso que el método debe de hacer. Es decir, por ejemplo, que nuestro método <code class=\"language-text\">pasar()</code> tiene responsabilidad “de más”: Cuando pasa un camión sólo le queremos cobrar a pdepCargas una cantidad y decirle al camión que recorra la ruta. El resto de la lógica podríamos abstraerla, para poder tener un código más legible y con métodos con sus respectivas “responsabilidades”.</p>\n<p>Esto se vería de la siguiente manera:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">object rutatlantica {\n\tmethod pasar(unCamion) {\n\t  pdepCargas.cobrar(self.costo(unCamion))\n\t  unCamion.recorrerRuta(400, self.velocidadQuePasa(unCamion))\n\t}\n\n\tmethod velocidadQuePasa(unCamion) {\n\t  return unCamion.velocidadMaxima().min(75)\n\t}\n\n\tmethod costo(unCamion) {\n\t  return 7000 + 100 * unCamion.pesoCarga() / 1000\n\t}\n}</code></pre></div>\n<h2 id=\"links-útiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links útiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links útiles:</h2>\n<ul>\n<li><a href=\"\">Código de la clase</a></li>\n<li><a href=\"https://drive.google.com/file/d/1gFTPSS11aW4aT1XUbvFZbK9DPq1Zmv_X/view?usp=sharing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Video de la clase</a></li>\n<li><a href=\"https://docs.google.com/document/d/1TIcIGa_rabX2MK9lR-AIDlhsCQ56a6HmakGah_zyl6g/edit#\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Pdep cargas</a></li>\n</ul>","frontmatter":{"title":"Doceava clase","date":"31-08-2020","description":"Doceava clase de PdeP","tags":["objetos","self","encapsulamiento","responsabilidad","delegación","polimorfismo."]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/objetos/clase-12/","previous":{"fields":{"slug":"/objetos/clase-11/"},"frontmatter":{"title":"Onceava clase"}},"next":{"fields":{"slug":"/objetos/clase-13/"},"frontmatter":{"title":"Treceava clase"}}}}}