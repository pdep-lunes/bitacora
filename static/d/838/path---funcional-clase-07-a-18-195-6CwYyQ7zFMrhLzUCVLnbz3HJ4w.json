{"data":{"site":{"siteMetadata":{"title":"BitÃ¡cora ğŸ“š","author":"pdep"}},"markdownRemark":{"id":"3b8a49a7-32b0-593b-ba8d-3600b3c00df9","excerpt":"Tarea para la clase que viene: Terminar todas las lecciones de  Mumuki Â¿QuÃ© vimos hoy? Recursividad Fold Simulacro de parcial Recursividad Â¿QuÃ© es laâ€¦","html":"<h2 id=\"tarea-para-la-clase-que-viene\"><a href=\"#tarea-para-la-clase-que-viene\" aria-label=\"tarea para la clase que viene permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tarea para la clase que viene:</h2>\n<p>Terminar todas las lecciones de <a href=\"https://mumuki.io/pdep-utn/chapters/315-programacion-funcional\">Mumuki</a></p>\n<h2 id=\"Â¿quÃ©-vimos-hoy\"><a href=\"#%C2%BFqu%C3%A9-vimos-hoy\" aria-label=\"Â¿quÃ© vimos hoy permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Â¿QuÃ© vimos hoy?</h2>\n<ul>\n<li>Recursividad</li>\n<li>Fold</li>\n<li>Simulacro de parcial</li>\n</ul>\n<h2 id=\"recursividad\"><a href=\"#recursividad\" aria-label=\"recursividad permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursividad</h2>\n<p>Â¿QuÃ© es la recursividad? La recursividad es como la recursividad. Claro, peroâ€¦ Â¿QuÃ© es la recursividad? La recursividad es como la recursividad. Claro, peroâ€¦ Â¿QuÃ© es la recursividad? ğŸ˜</p>\n<p>La <strong>recursividad</strong> es cuando a una funciÃ³n la definimos en tÃ©rminos de sÃ­ misma ğŸ”„. En otras palabras, cuando se invoca a la funciÃ³n dentro de sÃ­ misma.</p>\n<p>Â¿Te acordÃ¡s alguna funciÃ³n recursiva? Si rebobinÃ¡s âª hasta AM1 seguro te acuerdes de:</p>\n<p>Factorial â—\nFibonacci ğŸŒ</p>\n<p>Â¿Y cÃ³mo las codificamos en Haskell?</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">factorial</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token hvariable\">factorial</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">factorial</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></span></code></pre></div>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">0</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token hvariable\">fibonacci</span> <span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token hvariable\">fibonacci</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">fibonacci</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span><span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></span></code></pre></div>\n<p>En las dos soluciones podemos observar que hay <strong>como mÃ­nimo</strong>: ğŸ‘€\nUn <strong>caso recursivo</strong>, en el cual la funciÃ³n se llama a sÃ­ misma.\nUn <strong>caso base</strong>, el cual permite cortar la recursividad.</p>\n<p>Ahora que sabemos recursividad veamos cÃ³mo podemos definir algunas funciones que ya conocemos de listas:</p>\n<table>\n<thead>\n<tr>\n<th>Forma infija</th>\n<th>Forma prefija</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">sum [] = 0</code></td>\n<td><code class=\"language-text\">sum [] = 0</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">sum (x:xs) = x + sum xs</code></td>\n<td><code class=\"language-text\">sum (x:xs) = (+) x (sum xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">product [] = 1</code></td>\n<td><code class=\"language-text\">product [] = 1</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">product (x:xs) = x * product xs</code></td>\n<td><code class=\"language-text\">product (x:xs) = (*) x (product xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">and [] = True</code></td>\n<td><code class=\"language-text\">and [] = True</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">and (x:xs) = x &amp;&amp; and xs</code></td>\n<td><code class=\"language-text\">and (x:xs) = (&amp;&amp;) x (and xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">or [] = False</code></td>\n<td><code class=\"language-text\">or [] = False</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">or (x:xs) = x || or xs</code></td>\n<td><code class=\"language-text\">or (x:xs) = (||) x (or xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">concat [] = []</code></td>\n<td><code class=\"language-text\">concat [] = []</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">concat (x:xs) = x ++ concat xs</code></td>\n<td><code class=\"language-text\">concat (x:xs) = (++) x (concat xs)</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">aplicar v [] = v</code></td>\n<td><code class=\"language-text\">aplicar v [] = v</code></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">aplicar v (x:xs) = x $ aplicar v xs</code></td>\n<td><code class=\"language-text\">aplicar v (x:xs) = ($) x (aplicar v xs)</code></td>\n</tr>\n</tbody>\n</table>\n<p>Como podrÃ¡s ver estamos repitiendo lÃ³gica y, <a href=\"https://www.youtube.com/watch?v=8ktYyme_sUw\">Â¿quÃ© pasa cuando repetimos lÃ³gica?</a></p>\n<p>En todas estas funciones:\nEn el caso base nuestra funciÃ³n recibe la lista vacÃ­a (<code class=\"language-text\">[ ]</code>) y devuelve un <em>valor inicial</em>.\nEn el caso recursivo siempre tenemos a una operaciÃ³n que recibe:\nLa cabeza de la lista.\nLa llamada recursiva de la funciÃ³n que estamos definiendo con la cola como parÃ¡metro.</p>\n<p>Â¿Y cÃ³mo quitamos toda esta lÃ³gica repetida? ğŸ˜± Â¡Parametrizando!</p>\n<h2 id=\"fold\"><a href=\"#fold\" aria-label=\"fold permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fold</h2>\n<p>Para salvarnos de la repeticiÃ³n de lÃ³gica tenemos a nuestro gran amigo el <a href=\"https://docs.google.com/document/d/1jSrU7lVMan4nbHBETGqvO5VpqJI0KXVWtH7fqnVASPU/edit\">fold</a>. Ahora a nuestro <em>valor inicial</em> que se re repetÃ­a en todas nuestras funciones lo llamaremos <code class=\"language-text\">semilla</code>y al operador del caso recursivo lo llamaremos, simplemente, <code class=\"language-text\">funcion</code> . ğŸ˜œ</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldr</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">semilla</span>\n<span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">foldr</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldl</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">b</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>     <span class=\"token operator\">=</span>  <span class=\"token hvariable\">semilla</span>\n<span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token builtin\">foldl</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">semilla</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">xs</span></code></pre></div>\n<p>Peeeero, Â¿quÃ© pasa si queremos averiguar el mÃ¡ximo (o mÃ­nimo) valor dentro de una lista? Â¿QuÃ© puedo usar como semilla? ğŸŒ°</p>\n<p>Para los casos en los cuales no sabemos quÃ© semilla utilizar, tenemos a <code class=\"language-text\">foldl1</code> que usa el primer elemento de las lista como semilla:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\"><pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token builtin\">foldl1</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span><span class=\"token hvariable\">a</span><span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>\n<span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">_</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">x</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span>\n<span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">x</span><span class=\"token operator\">:</span><span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>  <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">x</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">foldl1</span> <span class=\"token hvariable\">funcion</span> <span class=\"token hvariable\">xs</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Como verÃ¡s <code class=\"language-text\">foldl1</code>, a diferencia de <code class=\"language-text\">foldl</code> y <code class=\"language-text\">foldr</code>, no funciona con listas vacÃ­as.</p>\n<p>Te invitamos a que pruebes en tu consola cÃ³mo funciona la familia foldl. ğŸ˜„</p>\n<h2 id=\"simulacro-de-parcial\"><a href=\"#simulacro-de-parcial\" aria-label=\"simulacro de parcial permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Simulacro de parcial</h2>\n<p>En lo que quedo de la clase estuvimos haciendo este <a href=\"/bitacora/parcial-funcional-tierra-de-barbaros-ff24d36187ac71de684aeb1c935a6fc5.pdf\">parcial</a> y como no llegamos a hacer una puesta en comÃºn les dejamos <a href=\"/bitacora/solucionParcialBarbaros-5dbe1ebff0d93095a854e498be8fc010.hs\">esta posible soluciÃ³n</a></p>\n<h2 id=\"links-Ãºtiles\"><a href=\"#links-%C3%BAtiles\" aria-label=\"links Ãºtiles permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Links Ãºtiles:</h2>\n<p><a href=\"http://wiki.uqbar.org/wiki/articles/recursividad-en-haskell.html\">Recursividad</a>\n<a href=\"http://wiki.uqbar.org/wiki/articles/fold.html\">Foldl</a>\n<a href=\"https://www.youtube.com/watch?v=veiQkxz59NE\">Video de foldl del gran profesor Alf</a></p>","frontmatter":{"title":"SÃ©ptima clase","date":"29-04-2019","description":"â€˜Recursividad, Fold'","tags":["funcional","recursividad","fold"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/funcional/clase-07/","previous":{"fields":{"slug":"/funcional/clase-06/"},"frontmatter":{"title":"Sexta clase"}},"next":null}}